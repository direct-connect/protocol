= ADC Extensions
Fredrik Ullner <ullner@gmail.com>
1.0.4 UNRELEASED, July 2010

== Abstract
These are the official extensions to ADC. This document is based on the
information contained in the ADC wiki and ADC forum - spefications from there are moved here
when they are mature and stable enough.

== Version history
The latest draft of the next version of this document as well as intermediate
and older versions can be downloaded from
$URL$.

This version corresponds to $Revision$.

=== Version 1.0
* Initial release created from original ADC 1.0 text
* Added PING extension

=== Version 1.0.1
* Added TS as additional MSG parameter
* Added DFAV

=== Version 1.0.2
* Added UCMD extension

=== Version 1.0.3
* Removed optional keywords from UCMD
* Added BLOM extension

=== Version 1.0.4 UNRELEASED
* Added magnet link extension to 'UCMD'
* Added NAT traversal extension 'NATT'
* Added referral field to STA
* Added upload queue field to STA
* Added partial file sharing extension 'PFSR'

== Extensions

=== TIGR - Tiger tree hash support

==== General

This extension adds Tiger tree hash support to the base protocol. It is
intended to be used both for identifying files and for purposes such as CID
generation and password negotiation

==== TIGR for shared files
All files shared by TIGR supporting clients must have been hashed using Merkle
Hash trees, as defined by
http://www.open-content.net/specs/draft-jchapweske-thex-02.html.  The Tiger
algorithm, as specified by http://www.cs.technion.ac.il/~biham/Reports/Tiger/,
functions as the hash algorithm. A base segment size of 1024 bytes must be
used when generating the tree, but clients may then discard parts of the tree
as long as at least 7 levels are kept or a block granularity of 64 KiB is
achieved.

Generally, the root of the tree (TTH) serves to identify a file uniquely.
Searches use it and it must be present in the file list. Further, the root of
the file list must also be available and discoverable via GFI. A client may
also request the rest of the tree using the normal client-client transfer
procedure. The root must be encoded using base32 encoding when converted to
text.

In the file list, each File element carries an additional attribute "TTH"
containing the base32-encoded value of the Tiger tree root.

In the GET/GFI type, the full tree may be accessed using the "tthl" type.

"tthl" transfers send the largest set of leaves available) as a binary stream
of leaf data, right-to-left, with no spacing in between them.  <start_pos>
must be set to 0 and <bytes> to -1 when requesting the data.  <bytes> must
contain the total binary size of the leaf stream in SND; by dividing this
length by the individual hash length, the number of leaves, and thus the leaf
level, can be deducted. The received leaves can then be used to reconstruct
the entire tree, and the resulting root must match the root of the file (this
verifies the integrity of the tree itself). Identifier must be a TTH root
value from the "TTH/" root.

In the GET/GFI namespace, files are identified by 
"TTH/<base32-encoded tree root>".

In SCH and GFI, the following attributes are added:

[options="autowidth"]
|=====
|TR |Tiger tree Hash root, encoded with base32.
|TD |Tree depth, index of the highest level of tree data available, root-only = 0, first level (2 leaves) = 1, second level = 2, etc...
|=====

=== BZIP - File list compressed with bzip2
This extension adds a special file "files.xml.bz2" in the unnamed root of the
share which contains "files.xml" compressed with bzip2 1.0.3+ (www.bzip.org).

=== ZLIB - Compressed communication
There are two variants of zlib support, FULL and GET, and only one should be
used on a each communications channel set up.

==== ZLIB-FULL
If, during SUP negotiation, a peer sends "ZLIF" in its support string, it must
accept two additional commands, ZON and ZOF. Upon reception of ZON the peer
must start decompressing the incoming stream of data with zlib before
interpreting it, and stop doing so after ZOF is received (in the compressed
stream). The compressing end must partially flush the zlib buffer after each
chunk of data to allow for decompression by the peer.

==== ZLIB-GET
The alternative is to send "ZLIG" to indicate that zlib is supported for
binary transfers using the GET command, but not otherwise. A flag "ZL1" is
added to the to the SND command to indicate that the data will come
compressed, and the client receiving requests it by adding the same flag to
GET (the sending client may ignore a request for a compressed transfer, but
may also use it even when not requested by the receiver). The <bytes>
parameter of the GET and SND commands is to be interpreted as the number of
uncompressed bytes to be transferred.

=== PING - Pinger extension
This extension can be supported by both clients and hubs, and when present, if hub
supports it, it must send additional information to the client ( otherwise normal
base client).

It's purpose is to send to hublist pingers additional information about the hub
 that otherwise it would be impossible to get as a normal user (eg. minimum share, 
 maximum user count, etc).

==== INF

Contexts : F

When the client supporting the PING extension connects, the hub must send its
normal INF along with the following added fields ( none mandatory, if not present,
it means hub has no restrictions in that matter, or non existent):

[options="header, autowidth"]
|=====
|Code | Type | Description
|HH |string |Hub Host address ( DNS or IP )
|WS |url |Hub Website
|NE |string |Hub Network
|OW |string |Hub Owner name
|UC |integer |Current User count
|SS |integer |Total share size
|SF |integer |Total files shared
|MS |integer |Minimum share required to enter hub ( bytes )
|XS |integer |Maximum share for entering hub ( bytes )
|ML |integer |Minimum slots required to enter hub
|XL |integer |Maximum slots for entering hub
|MU |integer |Minimum hubs connected where clients can be users
|MR |integer |Minimum hubs connected where client can be registered
|MO |integer |Minimum hubs connected where client can be operators
|XU |integer |Maximum hubs connected where clients can be users
|XR |integer |Maximum hubs connected where client can be registered
|XO |integer |Maximum hubs connected where client can be operators
|MC |integer |Maximum possible clients ( users ) who can connect
|UP |integer |Hub uptime (seconds)
|NI |string  |Hub name (from BASE)
|DE |string  |Hub description (from BASE)
VE |string  |Hub software version (from BASE)
|=====

The hub must continue to send the user list as for a normal user (move to
NORMAL state). The pinger may decide to go through or disconnect (eg. if it
doesn't require additional information about the users).

===== Example
====
 -pinger- HSUP ADBASE ADPING AD..
 -hub- ISUP ADBASE ADPING AD..
 -hub- ISID ..
 -hub- IINF NIhubname DEcurrent\stopic VE.. HHmyhub.no-ip.org:555 WShttp://myhub.no-ip.org/ OWmyname UC2231 SS.. SF.. MS0 ML0 MC5000
 - (pinger may disconnect)
====

==== Hub - Hublist communication

The same extension goes for hub- hublist communication. This way, the hub
takes the role of the client and the hublist of the server.

The hublist may send INF about itself with NI field which would become hublist
name and WS hublist web address.

===== Example
====
 -hub- HSUP ADBASE ADPING AD..
 -hublist- ISUP ADBASE ADPING AD..
 -hublist- IINF NIhublist_name WShublist_address
 -hub- HINF  NIhubname DEcurrent\stopic VE.. HHmyhub.no-ip.org:555 WShttp://myhub.no-ip.org/ OWmyname UC2231 SS.. SF.. MS0 ML0 MC5000
 -( disconnect )
====

=== TS - Timestamp in MSG
Timestamp of the moment when the message was sent, expressed in seconds since the Unix Epoch (January 1 1970 00:00:00 GMT).

=== DFAV - Distributed Favorites
The idea behind this extension is to generate a public hublist from the users favorite hublist. Implementations should separate between public and private hubs in the favorite hublist of an user, in order not to distribute private hubs where one can not connect to anyway.

==== GFAGFA

Contexts: T, C

Asks all users within the same hub with the correct feature to send all publicly available hubs, in their favorite hub list to the requesting client.

==== RFARFA

Contexts: C

Response of a client.

[options="autowidth"]
|=====
|HA | Hub address

|LG | Last succesfull login time ( number of seconds since the epoch (1970), (UTC) )|=====

All INF fields from BASE are inherited. All INF fields from PING extension are inherited.

=== UCMD - User commands

 CMD name

Contexts: F

States: NORMAL

User commands are used to send hub-specific commands to the client which provide useful shortcuts for the user. These commands contain strings which must be sent back to the hub and keyword substitutions in the strings. Each user command has a display name, a string to be sent to the hub, and one or more categories where it may appear. The strings passed to the hub must first be passed through a dictionary replacement that replaces all keywords in the string and then through the equivalent of the C standard function "strftime", with the current time.

Name uniquely (per hub) identifies a particular user command. The name may contain "/" to indicate a logical structure on the viewing client, where each "/" introduces a new submenu level. Other than name, the command also has a number of flags that further detail what to do with it.

[options="autowidth"]
|=====
|RM |1 = Remove Command
|CT |Message Category,  1 = Hub command, client parameters only, 2 = User list command, client and user parameters, 4 = Search result command, client, user and file parameters, 8 = File list command, client, user and file parameters.Multiple types are specified by adding the numbers together.
|TT |The full text to be sent to hub, including FOURCC, parameters and keywords.
|CO |1 = Constrained, when sending this command on multiple users (for example in search results), constrain it to once per CID only
|SP |1 = Insert separator instead of command name (name must still be present to uniquely identify the command).
|=====

==== Keywords
Keywords are specified using "%[keyword]". Unknown keywords must be replaced by the empty string. Additionally, all %-substitutions of the C function "strftime" must be supported.

The following tables specify the keywords that must be supported.

Client parameters[options="autowidth"]
|=====
|myCID |Client CID
|mySID |ClientSID
|myXX |One for each flag on that particular hub; for example, myI4 and myNI
|=====

User parameters
[options="autowidth"]
|=====
|userCID |User CID
|userSID |User SID
|userXX |One for each flag on the user sent; for example, userI4 and userNI
|line:info |Prompts the user for input where 'info' is the displayed text description for the user input
|=====

File parameters
[options="autowidth"]
|=====
|fileXX |One for each flag contained within a search result or file list entry (see RES)
|fileMN |Specify magnet link. http://en.wikipedia.org/wiki/Magnet_link[Magnet links] are used to reference files across networks and applications. Clients may ignore parameters it does not understand, but are free to pass on the parameters to other programs.
|=====

Hub parameters
[options="autowidth"]
|=====
|hubXX |One for each flag of the hub; for example, hubNI and hubVE
|=====

==== Example
====
ICMD ADCH++/Hub\smanagement/Register\snick TTHMSG\s+regnick\s%[userNI]\s%[line:Password\s(leave\sempty\sto\sun-reg)]\s%[line:Level\s(facultative;\sdefaults\sto\syour\sown\slevel\sminus\sone)]\n CT2

ICMD ADCH++/Hub\smanagement/Reload\sbans TTHMSG\s+loadbans\n CT3

ICMD ADCH++/Hub\smanagement/Reload\sscripts TTHMSG\s+reload\n CT3

ICMD ADCH++/Info TTHMSG\s+info\s%[userNI]\n CT2

ICMD ADCH++/Info TTHMSG\s+info\n CT1
====

=== BLOM- Bloom filter

Bloom filters allow the hub to filter certain searches using bitmap that represents the hashes of the files in the users share. BLOM is an extension that allows hub software to create a map (bloom filter) of the shared files on the hub, but with minimal effort, e.g. the hub doesn't keep a list of files, but a filter that never produces false negatives but only possible false positives. This can potentially save bandwidth and effort on the client side. When the user updates the share, the client must send an INF containing the flag SF. The hub may at any time request that the client sends an updated version of its bloom filter by sending a GET command to the client. The client will then respond using SND and send the bloom filter binary data.

==== Legend
[options="autowidth"]
|=====
|b |Number of bits used for file hashes
|n |Number of files in the user's share
|m |Size of the bloom filter in bits
|k |Number of sub-hashes constructed from the file hash
|h |Number of bits to use for each sub-hash
|p |Propability of a false positive
|=====

The hub chooses k, h and m.

==== Restrictions
[options="autowidth"]
|=====
|k * h < = b
|h < = 64
|2^h^ > m
|m mod 64 == 0
|=====

==== Probability
[options="autowidth"]
|=====
|p == (1 - (1 - 1 / m)^(k * n)^)^k^ |False positives
|p == 0 |False negatives
|=====

==== Protocol changes
Signal BLOM in SUP.

For the SND type, adds H as message type.

For the GET type, adds I as message type.

For the GET type, adds "blom" as type.

For the GET type, "/" shall be used as namespace.

For the GET type, 0 (zero) shall be used as start position.

For the GET type, m / 8 shall be used as byte amount.

Updates GET with the following flags;
[options="autowidth"]
|=====
|BK |Specify 'k'.
|BH |Specify 'h'.
|=====

==== Algorithm
The client constructs the bloom filter by creating a bit array of m bits set to 0 (zero). For each file it then sets to "1" k positions constructed from the file hash. Seeing the file hash as a stream of bits (starting from the lowest bit of the first byte, ending at the highest bit of the last byte), the client should use h bits starting at the first bit of the first byte to create an integer and apply modulo m to get the position in the bit array, then redo the process k times advancing the starting position by h each time.

Once the hub has received the bloom filter bit array, for each search command it processes, if it contains a hash search term, it can skip broadcasting the search to a particular client if at least one of the k bits in that clients bit array is "0", calculating positions as the client does when setting bits to "1". The hub has to evaluate the filter for each client that it has a bloom filter for, for each search.

==== Probability calculations
p = (1 - (1 - 1 / m)^(k * n)^)^k^, thus p becomes smaller as m grows and larger as n grows. Larger m means more bits to transfer but also fewer false positives. The optimum value for k given m and n is (m / n) * ln 2. The largest k supported by a hash of a certain size is b / h, so if the hub wants the smallest p possible, it should choose the smallest possible h which gives the largest k, and then calculate m = k * n/ln 2, checking that the resulting m < 2^h^. 2^h^ should much be larger than m (at least 3-4 times), because of how the modulo operator works. Also, with m grows the required bandwidth to transfer the bloom filter, so the hub may wish to cap m. In that case, it should still choose k according to m / n * ln 2, but send an h as big as possible to alleviate biasing problems.

==== Sample implementations
===== Tiger
For TTH roots, b is 192 and a reasonable value for h is 24, giving a maximum k = 8 which means that m = 8 * n / ln 2 ≈ 11.5 * n. The required bandwidth then becomes 11.5 * n / 8 bytes, so approximately 1.44 bytes per file in the users share. For 20000 files, m should then be 230016 (taking into account the modulo 64 requirement), giving a p = 0.004, in other words ~99.6% of all searches that don't match a users share would not be sent, saving valuable upload bandwidth for the hub. The client calculates i valid positions, if x is an array of bytes containing the hash of the file, on a little-endian machine, by doing pos = x[0+i*h/8] | (x[1+i*h/8] << 8) | (x[2+i*h/8] << 16) for i = [0;k). This is of course a special case where h % 8 = 0, the actual algorithm has to take into consideration values for h where the integer crosses byte boundaries.

For test vectors, see the http://www.adcportal.com/wiki/index.php/Talk:BLOM[ADC wiki talk page].

=== NATT - NAT traversal
NAT traversal allow two passive clients to connect to each other. For more information about NAT traversal, see https://dcpp.wordpress.com/2010/02/13/passive-mode-c-c-connections-and-nat-traversal[Passive Mode C-C Connections and NAT Traversal].

If a client does not support TCP4 or TCP6, it will send an RCM to the client it is trying to connect to. If the other client also doesn't support TCP4 (or TCP6 correspondingly), NAT traversal may instead be used.  The feature should be signalled in SUP as NATT.

Do note that the hub must forward I4 or I6 for respective clients' INF.

==== BASE RCM updates
When receiving an RCM and the client does not support TCP4 or TCP6, and if NAT-T is supported in the remote client, a NAT command should be sent repeating the protocol and token. The port shall be the outbound port to the connected hub.

====  NAT
 NAT protocol port token

Contexts: T

States: NORMAL

Upon receiving this, try and connect to the specified port.  An RNT command should be sent repeating the protocol and token. The port shall be the outbound port to the connected hub. Upon receiving this, try and connect to the specified port.

==== RNT
 RNT protocol port token

Contexts: T

States: NORMAL

Upon receiving this, try and connect to the specified port.

==== Example
Client A is connected to hub A with the outbound port 1000 and client B is connected to hub A with the outbound port 2000. Client A has the SID AAAA and client B has the SID BBBB.

====
Client A: DRCM AAAA BBBB ADC/1.0 foobar

Client B: DNAT BBBB AAAA ADC/1.0 2000 foobar

<Client A connects to client B's IP address and port 2000>

Client A: DRNT AAAA BBBB ADC/1.0 1000 foobar

<Client B connects  to client A's IP address and port 1000>
======= RF - Referrer notification
Extends the RF field of the INF to STA, allowing a client to notify clients and hubs upon SUP-negotiation from where the C-C or C-H originated from.

[options="autowidth"]
|=====
|RF |URL of referrer
|=====

==== Example
====
CSUP ADBASE (...)

CSTA 000 referrer RFadc://example.com:1234
====

=== QP - Upload queue notification
This extension's purpose is creating a queue on a client, when multiple other clients want to download from it, but they have no slots. Currently, when a slot is being freed, the first connecting client gets it. Other clients that don't have the luck of getting in time to attempt to download, have to wait again. The client who creates a queue must have a ticket number for each connecting client, which must be kept internally , and a difference between current connecting client's queue number and the currently uploading client's be provided to the connecting client, so that the clients are being deserved in the order they originally connected. The client could have a ticket incrementing starting from 1 for each session. Connecting slients must use the same token as they used when originally connected.

[options="autowidth"]
|=====
|QP |Queue number, representing how many others are in front in the queue.
|=====

==== Example
The following example will notify that the client's slots are full and that there are three uploads in the queue.
====
CSTA 253 No\sslots\savailable QP3
====

=== PFSR - Partial file sharing
Partial File Sharing allows sharing of files which are available in user's download queue or in finished downloads list. As a result of this, new files will be spread much faster over whole network.

When client receives search request (SCH), it looks into shared list to see whether requested hash is available between shared files. If it's found, everything is processed as normally. In other case, it looks into download queue (then, into finished downloads list) and receives a list of available chunks for requested hash. It mustn't take every chunk, but only that ones which are fully downloaded and has already been verified (e.g. against TTH leaves).

 The feature should be signalled in SUP as PFSR.

==== PSR
 PSR

Contexts: F, U

States: NORMAL

Information about downloaded and verified chunks is sent to requester with this command. When the requester is active command is sent over UDP (with U context) else it is sent over hub (with D context).
[options="autowidth"]
|====
|U4 |UDP IPv4 port or 0 if we don't want receive a response. If UDP port is not zero (it must be when we are passive user), a PSR receiver must respond us with PSR including his available (and verified) chunks. The client must also set UDP port to zero to avoid infinite PSR sending.
|U6 | Same as U4 but with IPv6 port.
|TR |File hash
|PC |Count of downloaded (and verified) chunks the user has.
|PI |Comma separated list of start and end index of chunks the user has. If a user has a continous block of chunks, the intermittent start and end indexes may be omitted. For example, if a user has chunk 0 and 4 of total 5 chunks, then PI is "0,1,4,5". If the user has chunk 0, 1 and 4, then PI may be "0,1,1,2,4,5" or "0,2,4,5".
|====

// vim: set syntax=asciidoc:
